name: Deploy to Azure VM

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.VM_SSH_PRIVATE_KEY }}

    - name: Add VM to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to VM
      run: |
        ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} << 'EOF'
          set -e
          
          # Navigate to application directory
          cd /opt/klarifai
          
          # Pull latest code
          if [ -d ".git" ]; then
            echo "Updating existing repository..."
            git fetch origin
            git reset --hard origin/main
          else
            echo "Cloning repository..."
            git clone ${{ secrets.REPO_URL }} .
          fi
          
          # Create production environment file
          cat > .env.production << EOL
          DEBUG=False
          DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
          ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}
          CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }}
          REDIS_URL=redis://redis:6379/0
          EOL
          
          # Stop existing containers
          echo "Stopping existing containers..."
          docker-compose --env-file .env.production down || true
          
          # Remove old images (optional, saves space)
          docker image prune -f || true
          
          # Build and start new containers
          echo "Building and starting containers..."
          docker-compose --env-file .env.production up -d --build
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
          
          # Run database migrations
          echo "Running migrations..."
          docker-compose --env-file .env.production exec -T backend python manage.py migrate
          
          # Collect static files
          echo "Collecting static files..."
          docker-compose --env-file .env.production exec -T backend python manage.py collectstatic --noinput
          
          # Create superuser if it doesn't exist
          echo "Creating superuser..."
          docker-compose --env-file .env.production exec -T backend python manage.py shell << PYTHON
          from django.contrib.auth import get_user_model
          User = get_user_model()
          if not User.objects.filter(username='${{ secrets.DJANGO_SUPERUSER_USERNAME }}').exists():
              User.objects.create_superuser(
                  username='${{ secrets.DJANGO_SUPERUSER_USERNAME }}',
                  email='${{ secrets.DJANGO_SUPERUSER_EMAIL }}',
                  password='${{ secrets.DJANGO_SUPERUSER_PASSWORD }}'
              )
              print("Superuser created successfully")
          else:
              print("Superuser already exists")
          PYTHON
          
          # Check service health
          echo "Checking service health..."
          docker-compose --env-file .env.production ps
          
          # Test API endpoint
          sleep 10
          curl -f http://localhost/api/datasets/ || echo "API test failed, but continuing..."
          
          echo "Deployment completed successfully!"
        EOF

    - name: Verify deployment
      run: |
        ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} << 'EOF'
          cd /opt/klarifai
          echo "=== Container Status ==="
          docker-compose --env-file .env.production ps
          
          echo "=== Backend Logs (last 20 lines) ==="
          docker-compose --env-file .env.production logs --tail=20 backend
          
          echo "=== Database Status ==="
          docker-compose --env-file .env.production exec -T database pg_isready -U postgres
        EOF

    - name: Cleanup old Docker resources
      run: |
        ssh ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} << 'EOF'
          # Clean up unused Docker resources
          docker system prune -f
          docker volume prune -f
        EOF